<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/ficon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png"><link rel="mask-icon" href="/images/icon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"bqlin.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!0,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:-1,unescape:!1,preload:!1},motion:{enable:!1,async:!0,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Grand Central Dispatch（GCD）调度队列是执行任务的强大工具。调度队列让你可以相对于调用者异步或同步地执行任意的代码块。你可以使用调度队列来执行几乎所有你过去在独立线程上执行的任务。调度队列的优点是使用起来更简单，执行任务的效率相比线程代码高得多。 本章介绍了调度队列，以及如何执行程序中的一般任务。如果你想用调度队列替换现有的线程代码，可参阅迁移线程代码。"><meta property="og:type" content="article"><meta property="og:title" content="Concurrency Programming Guide：调度队列"><meta property="og:url" content="https://bqlin.github.io/posts/concurrency_pg_dispatch_queues/index.html"><meta property="og:site_name" content="權咚领域"><meta property="og:description" content="Grand Central Dispatch（GCD）调度队列是执行任务的强大工具。调度队列让你可以相对于调用者异步或同步地执行任意的代码块。你可以使用调度队列来执行几乎所有你过去在独立线程上执行的任务。调度队列的优点是使用起来更简单，执行任务的效率相比线程代码高得多。 本章介绍了调度队列，以及如何执行程序中的一般任务。如果你想用调度队列替换现有的线程代码，可参阅迁移线程代码。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-09-08T09:42:58.000Z"><meta property="article:modified_time" content="2021-11-13T09:49:10.000Z"><meta property="article:author" content="權咚"><meta property="article:tag" content="Apple"><meta property="article:tag" content="Concurrency Programming Guide"><meta property="article:tag" content="多线程"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://bqlin.github.io/posts/concurrency_pg_dispatch_queues/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Concurrency Programming Guide：调度队列 | 權咚领域</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-105338942-1"></script><script>function gtag(){dataLayer.push(arguments)}CONFIG.hostname===location.hostname&&(window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-105338942-1"))</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?98fcf61fd269408d07dcbc1e49311f9a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="權咚领域" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">權咚领域</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Making app a work of art.</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://bqlin.github.io/posts/concurrency_pg_dispatch_queues/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/icon.png"><meta itemprop="name" content="權咚"><meta itemprop="description" content="🤘🤯👾"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="權咚领域"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Concurrency Programming Guide：调度队列</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-09-08 17:42:58" itemprop="dateCreated datePublished" datetime="2021-09-08T17:42:58+08:00">2021-09-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-11-13 17:49:10" itemprop="dateModified" datetime="2021-11-13T17:49:10+08:00">2021-11-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>20k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>19 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>Grand Central Dispatch（GCD）调度队列是执行任务的强大工具。调度队列让你可以相对于调用者异步或同步地执行任意的代码块。你可以使用调度队列来执行几乎所有你过去在独立线程上执行的任务。调度队列的优点是使用起来更简单，执行任务的效率相比线程代码高得多。</p><p>本章介绍了调度队列，以及如何执行程序中的一般任务。如果你想用调度队列替换现有的线程代码，可参阅<a href=".%2F05%20Migrating%20Away%20from%20Threads.md">迁移线程代码</a>。</p><span id="more"></span><h2 id="关于调度队列">关于调度队列</h2><p>调度队列是在程序中异步和并发地执行任务的一种简单方法。一个<em>任务</em>只是程序需要执行的一些工作。例如，你可以定义一个任务来执行一些计算，创建或修改一个数据结构，处理从文件中读取的一些数据，或任何数量的事情。定义任务的方式是将相应的代码放在一个函数或一个block对象中，并将其添加到一个调度队列中。</p><p>调度队列是一个类似于对象的结构，管理提交给它的任务。所有调度队列都是先入先出的数据结构。因此，添加到队列中的任务总是按照它们被添加的相同顺序启动。GCD已经提供了一些调度队列，但你也可以为特定的目的而创建其他调度队列。表3-1列出了程序可用的调度队列的类型及其用法。</p><p><strong>表3-1</strong> 调度队列类型</p><table><colgroup><col style="width:14%"><col style="width:85%"></colgroup><thead><tr class="header"><th>类型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>串行</td><td>串行队列（也称为<em>私有调度队列</em>）按照添加到队列的顺序，一次执行一个任务。当前执行的任务在一个独立的线程上运行（可以因任务而异），该线程由调度队列管理。串行队列通常用于同步访问特定的资源。<br>你可以根据需要创建足够多的串行队列，每个队列相对于所有其他队列都是并发执行的。换句话说，如果你创建了四个串行队列，每个队列一次只执行一个任务，但最多可以有四个任务同时执行，每个队列一个。有关如何创建串行队列的信息，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW6">Creating Serial Dispatch Queues</a>。</td></tr><tr class="even"><td>并发</td><td>并发队列（也被称为<em>全局调度队列</em>的一种类型）同时执行一或多个任务，但任务仍然按照它们被添加到队列的顺序启动。当前执行的任务在不同的线程上运行，这些线程由调度队列管理。在任何时候执行的任务的确切数量是根据系统条件而决定。<br>在iOS 5和更高版本中，可以通过指定<code>DISPATCH_QUEUE_CONCURRENT</code>队列类型，自己创建并发的调度队列。此外，还有四个预定义的全局并发队列供程序使用。关于如何获得全局并发队列的更多信息，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW5">Getting the Global Concurrent Dispatch Queues</a>。</td></tr><tr class="odd"><td>主调度队列</td><td>主调度队列是一个全局可用的串行队列，在程序的主线程上执行任务。这个队列与程序的run loop（如果有的话）配合工作，将队列任务的执行与连接到run loop的其他事件源的执行交错进行。因为它在程序的主线程上运行，所以主队列经常被用作程序的关键同步点。<br>虽然你不需要创建主调度队列，但你需要确保程序适当地使用它。关于如何管理该队列的更多信息，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW15">Performing Tasks on the Main Thread</a>。</td></tr></tbody></table><p>当涉及到向程序添加并发特性时，调度队列比线程有几个优势。最直接的优势是工作队列编程模型的简单性。对于线程，你必须为要执行的工作以及线程本身的创建和管理编写代码。调度队列让你专注于你真正想要执行的工作，而不必担心线程的创建和管理。相反，系统为你处理所有的线程创建和管理。这样做的好处是，系统能够比任何单个程序更有效地管理线程。系统可以根据可用的资源和当前的系统条件，动态地扩展线程的数量。此外，系统通常能够比你自己创建的线程更快地开始运行你的任务。</p><p>尽管你可能认为为调度队列重写代码会很困难，但为调度队列编写代码往往比为线程写代码要容易。编写代码的关键是设计自成一体且能够异步运行的任务。（这对线程和调度队列都是如此。）然而，调度队列的优势在于可预测性。如果你有两个访问同一共享资源的任务，但在不同的线程上运行，任何一个线程都可以先修改资源，你需要使用一个锁来确保两个任务不会同时修改该资源。有了调度队列，你可以将两个任务添加到一个串行调度队列中，以确保在任何时候只有一个任务修改资源。这种基于队列的同步比锁更有效，因为锁在有争议和无争议的情况下总是需要一个昂贵的内核陷阱（kernel trap），而调度队列主要在程序的进程空间工作，只有在绝对必要时才会向下调用内核。</p><p>尽管你会正确地指出，在一个串行队列中运行的两个任务不会并发运行，但你必须记住，如果两个线程同时取得一个锁，那么线程提供的任何并发性都会丢失或大大降低。更重要的是，线程模型需要创建两个线程，这需要占用内核和用户空间的内存。调度队列不会为它们的线程而消耗同样的内存，而且他们使用的线程会保持持续工作，不会被阻塞。</p><p>关于调度队列，需要记住的其他一些关键点：</p><ul><li><p>调度队列相对于其他调度队列来说，是同时执行其任务的。任务的串行是相对于一个调度队列而言的。</p></li><li><p>系统决定了在任何时候执行的任务总数。因此，一个在100个不同队列中有100个任务的程序可能不会并发地执行所有这些任务（除非它有100个或更多的有效内核）。</p></li><li><p>系统在选择启动哪些新任务时，会考虑到队列的优先级。关于如何设置一个串行队列的优先级，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW7">Providing a Clean Up Function For a Queue</a>。</p></li><li><p>队列中的任务在被添加到队列时，必须准备好执行。（如果之前使用过Cocoa操作对象，请注意这种行为与操作对象使用的模型不同。）</p></li><li><p>私有调度队列是引用计数的对象。除了在你自己的代码中保留队列外，要注意调度源也可以附加到队列上，也会增加其保留计数。因此，你必须确保所有的调度源都被取消，所有的保留调用都与适当的释放调用相平衡。关于保留和释放队列的更多信息，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW11">Memory Management for Dispatch Queues</a>。关于调度源的更多信息，可参阅<a href=".%2F04%20Dispatch%20Sources.md">调度源</a>。</p></li></ul><h2 id="队列相关技术">队列相关技术</h2><p>除了调度队列之外，Grand Central Dispatch还提供了一些使用队列来帮助管理代码的技术。表3-2列出了这些技术，并提供了链接，你可以在那里找到关于它们的更多信息。</p><p><strong>表3-2</strong> 使用调度队列的技术</p><table><colgroup><col style="width:14%"><col style="width:85%"></colgroup><thead><tr class="header"><th>技术</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>调度组</td><td>调度组是一种监视一组block对象完成的方式。你可以根据你的需要同步或异步地监视这些block。对于依赖其他任务完成的代码，组提供了一种有用的同步机制。关于使用组的更多信息，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW25">Waiting on Groups of Queued Tasks</a>。</td></tr><tr class="even"><td>调度信号量</td><td>调度信号与传统的信号量类似，但通常更有效率。只有当调用线程因为信号量不可用而需要被阻塞时，调度信号量才会向下调用内核。如果信号量是可用的，则不会调用内核。关于如何使用调度信号量的例子，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW24">Using Dispatch Semaphores to Regulate the Use of Finite Resources</a>。</td></tr><tr class="odd"><td>调度源</td><td>调度源在响应特定类型的系统事件时生成通知。你可以使用调度源来监控事件，如进程通知、信号和描述符事件等等。当一个事件发生时，调度源会将你的任务代码异步提交给指定的调度队列进行处理。关于创建和使用调度源的更多信息，可参阅<a href=".%2F04%20Dispatch%20Sources.md">调度源</a>。</td></tr></tbody></table><h2 id="使用block来实现任务">使用Block来实现任务</h2><p>Block对象是一种基于C语言的特性，你可以在C、Objective-C和C++代码中使用。Block使得定义一个独立的工作单元变得容易。尽管它们看起来类似于函数指针，但block实际上是由一个类似于对象的底层数据结构表示的，并由编译器为你创建和管理。编译器将你提供的代码（以及任何相关的数据）打包，并将其封装成一种可以存在堆中并在程序中传递的形式。</p><p>Block的关键优势之一是它们能够使用其自身词法范围之外的变量。当你在一个函数或方法中定义一个block时，该block在某些方面就像一个传统的代码块一样。例如，block可以读取定义在父作用域中的变量的值。被block访问的变量被复制到堆上的block数据结构中，这样block就可以在以后访问它们。当block被添加到调度队列时，这些值通常必须以只读的格式留下。然而，同步执行的block也可以使用预加了<code>__block</code>关键字的变量，将数据返回到父类的调用范围。</p><p>你可以使用类似于函数指针的语法，在你的代码中内联地声明block。Block和函数指针的主要区别是，block名称前面有一个<code>^</code>而不是<code>*</code>。像函数指针一样，你可以向block传递参数，并从它那里接收一个返回值。清单3-1显示了如何在代码中同步声明和执行block。变量<code>aBlock</code>被声明为一个block，它接受一个整数参数，不返回任何值。然后，一个符合该原型的实际block被分配给<code>aBlock</code>，并被声明为内联。最后一行立即执行该block，将指定的整数打印到标准输出：</p><p><strong>清单3-1</strong> block简单示例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">456</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Block declaration and assignment</span></span><br><span class="line"><span class="keyword">void</span> (^aBlock)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> z) &#123;</span><br><span class="line">    printf(<span class="string">&quot;%d %d %d\n&quot;</span>, x, y, z);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Execute the block</span></span><br><span class="line">aBlock(<span class="number">789</span>);   <span class="comment">// prints: 123 456 789</span></span><br></pre></td></tr></table></figure><p>下面是你在设计block时应该考虑的一些关键准则：</p><ul><li>对于你计划使用调度队列异步执行的block，从父函数或方法中捕获标量变量并在block中使用是安全的。然而，你不应该试图捕获大型结构体或其他基于指针的变量，这些变量是由调用上下文分配和删除的。当你的block被执行时，该指针所引用的内存可能已经被回收。当然，自己分配内存（或对象）并明确地将该内存的所有权移交给block是安全的。</li><li>调度队列会复制被添加到其中的block，并在执行完毕后释放block。换句话说，你不需要在将block添加到队列之前显式地复制它们。</li><li>尽管队列在执行小任务时比原始线程更有效，但在队列中创建block并执行它们仍然存在开销。如果一个block做的工作太少，直接执行它可能比把它调度到队列中更节省开销。判断一个block是否做得太少的方法是使用性能工具收集每个路径的指标并进行比较。</li><li>不要缓存相对于底层线程的数据，并期望该数据能从不同的block中访问。如果同一队列中的任务需要共享数据，请使用调度队列的上下文指针来代替存储数据。关于如何访问调度队列的上下文数据的更多信息，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW13">Storing Custom Context Information with a Queue</a>。</li><li>如果block创建了几个以上的Objective-C对象，你可以把block的部分代码包裹在@autorelease中，以处理这些对象的内存管理。尽管GCD调度队列有他们自己的自动释放池，但他们不保证这些池何时被耗尽。如果程序有内存限制，创建自己的自动释放池可以让你在更有规律的时间间隔内释放自动释放对象的内存。</li></ul><p>关于block的更多信息，包括如何声明和使用它们，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502">Blocks Programming Topics</a>。关于如何将block添加到调度队列中，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW20">Adding Tasks to a Queue</a>。</p><h2 id="创建和管理调度队列">创建和管理调度队列</h2><p>在你把任务添加到队列中之前，你必须确定使用的队列类型以及后续打算如何使用它。调度队列可以串行或并发地执行任务。此外，如果你对队列有一个特定的用途，你可以相应地配置队列属性。下面几节告诉你如何创建调度队列并配置它们的用途。</p><h3 id="获得全局并发调度队列">获得全局并发调度队列</h3><p>当你有多个可以并行运行的任务时，并发调度队列很有用。并发队列仍然是一个队列，因为它以先进先出的顺序对任务进行排队；但是，并发队列可能在任何先前的任务完成之前就排队等候其他任务。并发队列在任何给定时刻执行的实际任务数是可变的，可以随着程序的条件变化而动态变化。许多因素会影响并发队列执行的任务数量，包括可用的内核数量、其他进程正在完成的工作量，以及其他串行调度队列中的任务数量和优先级。</p><p>系统为每个程序提供了4个并发的调度队列。这些队列对程序来说是全局性的，仅由其优先级来区分。因为它们是全局的，所以你不需要明确地创建它们。相反，你可以使用<code>dispatch_get_global_queue</code>函数来请求获取其中的队列，如下所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> aQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>除了获得默认的并发队列，你还可以通过向函数传递<code>DISPATCH_QUEUE_PRIORITY_HIGH</code>和<code>DISPATCH_QUEUE_PRIORITY_LOW</code>常量来获得高优先级和低优先级的队列，或者通过传递<code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code>常量来获得一个后台队列。正如你所期望的，高优先级并发队列中的任务在默认队列和低优先级队列中的任务之前执行。同样地，默认队列中的任务在低优先级队列中的任务之前执行。</p><p><strong>注意：</strong> <code>dispatch_get_global_queue</code>函数的第二个参数是为将来的扩展保留的。现在，你应该总是为这个参数传递<code>0</code>。</p><p>尽管调度队列是引用计数的对象，你不需要保留和释放全局并发队列。因为它们对程序是全局的，对这些队列的保留和释放调用应被忽略。因此，你不需要存储对这些队列的引用。你只需在需要其中一个队列的引用时调用<code>dispatch_get_global_queue</code>函数。</p><h3 id="创建串行调度队列">创建串行调度队列</h3><p>当你想让你的任务以特定的顺序执行时，串行队列很有用。串行队列一次只执行一个任务，并且总是从队列的头部取出任务。你可以用一个串行队列代替锁来保护一个共享资源或可变数据结构。与锁不同，串行队列确保任务以可预测的顺序执行。<strong>只要你以异步方式向串行队列提交任务，该队列就不会出现死锁。</strong></p><p>与并发队列不同，你必须明确地创建和管理你想使用的任何串行队列。你可以为程序创建任何数量的串行队列，但应避免仅仅作为一种同时执行尽可能多的任务的手段来创建大量的串行队列。如果你想同时执行大量的任务，请将它们提交给全局并发队列。在创建串行队列时，尽量为每个队列确定一个目的，如保护资源或同步程序的一些关键行为。</p><p>清单3-2显示了创建一个自定义串行队列所需的步骤。<code>dispatch_queue_create</code>函数需要两个参数：队列名称和一组队列属性。调试器和性能工具会显示设置的队列名称，以帮助你跟踪任务的执行情况。队列属性是为将来使用而保留的，应该是<code>NULL</code>。</p><p><strong>清单3-2</strong> 创建一个串行队列</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue;</span><br><span class="line">queue = dispatch_queue_create(<span class="string">&quot;com.example.MyQueue&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>除了创建的任何自定义队列外，系统还自动创建一个串行队列，并将其绑定到程序的主线程。关于获取主线程的队列的更多信息，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW3">Getting Common Queues at Runtime</a>。</p><h3 id="在运行时获取通用队列">在运行时获取通用队列</h3><p>Grand Central Dispatch提供了一些函数，可以让你从程序中访问几个常见的调度队列：</p><ul><li>使用<code>dispatch_get_current_queue</code>函数用于调试目的或测试当前队列的身份。从一个block对象内部调用这个函数，会返回该block被提交到的队列（以及它现在可能正在运行的队列）。在block外调用此函数会返回程序的默认并发队列。</li><li>使用<code>dispatch_get_main_queue</code>函数来获取与程序主线程相关的串行调度队列。这个队列是为Cocoa程序和那些调用<code>dispatch_main</code>函数或在主线程上配置run loop（使用<code>CFRunLoopRef</code>类型或<code>NSRunLoop</code>对象）的程序自动创建的。</li><li>使用<code>dispatch_get_global_queue</code>函数来获取任何共享的并发队列。更多信息，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW5">Getting the Global Concurrent Dispatch Queues</a>。</li></ul><h3 id="调度队列的内存管理">调度队列的内存管理</h3><p>调度队列和其他调度对象是引用计数的数据类型。你可以使用<code>dispatch_retain</code>和<code>dispatch_release</code>函数根据需要增加和减少该引用计数。当一个队列的引用计数达到0时，系统会异步地释放队列。</p><p>保留和释放调度对象，如队列，以确保它们在被使用时仍在内存中，这一点很重要。与内存管理的Cocoa对象一样，一般的规则是，如果你打算使用传递给你的代码的队列，你应该在使用它之前保留该队列，当你不再需要它时释放它。这种基本模式可以确保只要你在使用队列，它就会一直留在内存中。</p><p><strong>注意：</strong>你不需要保留或释放任何全局调度队列，包括并发的调度队列或主调度队列。任何试图保留或释放队列的行为都会被忽略。</p><p>即使你实现了一个垃圾收集的程序，你仍然必须保留和释放你的调度队列和其他调度对象。Grand Central Dispatch不支持用于回收内存的垃圾收集模型。</p><h3 id="用队列存储自定义上下文信息">用队列存储自定义上下文信息</h3><p>所有的调度对象（包括调度队列）都允许将自定义上下文数据与该对象相关联。为了在一个给定的对象上设置和获取这些数据，你可以使用<code>dispatch_set_context</code>和<code>dispatch_get_context</code>函数。系统不会以任何方式使用你的自定义数据，而是由你在适当的时候分配和释放该数据。</p><p>对于队列，你可以使用上下文数据来存储一个指向Objective-C对象或其他数据结构的指针，以帮助识别队列或其他预期用途。你可以使用队列的析构函数，在队列被释放之前，将上下文数据从队列中释放（或取消关联）。如何编写一个清除队列上下文数据的析构函数的例子，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW8">清单3-3</a>。</p><h3 id="为队列提供一个清理函数">为队列提供一个清理函数</h3><p>在创建了一个串行调度队列后，可以附加一个析构函数，以便在队列被释放时执行任何自定义的清理工作。调度队列是引用计数的对象，你可以使用 <code>dispatch_set_finalizer_f</code> 函数来指定一个当队列的引用计数达到零时要执行的函数。你用这个函数来清理与队列相关的上下文数据，只有当上下文指针不是<code>NULL</code>时才会调用这个函数。</p><p>清单3-3显示了一个自定义的析构函数和一个创建队列并配置析构函数的函数。队列使用析构函数来释放存储在队列上下文指针中的数据。代码中引用的<code>myInitializeDataContextFunction</code>和<code>myCleanUpDataContextFunction</code>函数是你提供的自定义函数，用于初始化和清理数据结构本身的内容。传递给析构函数的上下文指针包含与队列相关的数据对象。</p><p><strong>清单3-3</strong> 给队列配置清理函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> myFinalizerFunction(<span class="keyword">void</span> *context)</span><br><span class="line">&#123;</span><br><span class="line">    MyDataContext* theData = (MyDataContext*)context;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Clean up the contents of the structure</span></span><br><span class="line">    myCleanUpDataContextFunction(theData);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Now release the structure itself.</span></span><br><span class="line">    free(theData);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">dispatch_queue_t</span> createMyQueue()</span><br><span class="line">&#123;</span><br><span class="line">    MyDataContext*  data = (MyDataContext*) malloc(<span class="keyword">sizeof</span>(MyDataContext));</span><br><span class="line">    myInitializeDataContextFunction(data);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create the queue and set the context data.</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">&quot;com.example.CriticalTaskQueue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    dispatch_set_context(serialQueue, data);</span><br><span class="line">    dispatch_set_finalizer_f(serialQueue, &amp;myFinalizerFunction);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> serialQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加任务到队列">添加任务到队列</h2><p>要执行一个任务，你必须把它调度到一个适当的调度队列中。你可以同步或异步地调度任务，你可以单独或分组地调度任务。一旦进入队列，考虑到队列的限制和队列中已有的任务，队列将负责尽快执行你的任务。本节向你展示了一些向队列调度任务的技术，并介绍了每一种技术的优点。</p><h3 id="添加单个任务到队列">添加单个任务到队列</h3><p>有两种方法可以将任务添加到队列中：异步或同步。在可能的情况下，使用<code>dispatch_async</code>和<code>dispatch_async_f</code>函数的异步执行比同步执行要好。当你在队列中添加一个block对象或函数时，没有办法知道该代码何时执行。因此，异步添加block或函数可以让你安排代码的执行，并继续从调用线程做其他工作。如果从程序的主线程调度任务（也许是为了响应一些用户事件）这一点就特别重要。</p><p>尽管你应该尽可能地异步添加任务，但有时你仍然需要同步添加任务，以防止竞态条件或其他同步错误。在这些情况下，你可以使用<code>dispatch_sync</code>和<code>dispatch_sync_f</code>函数来将任务添加到队列中。这些函数会阻塞当前的执行线程，直到指定的任务执行完毕。</p><p><strong>重要提醒：</strong>你不应该从一个正在执行的任务中调用<code>dispatch_sync</code>或<code>dispatch_sync_f</code>函数，而这个任务是你计划传递给该函数的同一个队列。这对串行队列特别重要，因为这样做必然导致死锁。同样对并发队列也应避免这样做。</p><p>下面的例子显示了如何使用基于block的变体来进行异步和同步的任务调度：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> myCustomQueue;</span><br><span class="line">myCustomQueue = dispatch_queue_create(<span class="string">&quot;com.example.MyCustomQueue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">dispatch_async</span>(myCustomQueue, ^&#123;</span><br><span class="line">    printf(<span class="string">&quot;Do some work here.\n&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">printf(<span class="string">&quot;The first block may or may not have run.\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">dispatch_sync</span>(myCustomQueue, ^&#123;</span><br><span class="line">    printf(<span class="string">&quot;Do some more work here.\n&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">printf(<span class="string">&quot;Both blocks have completed.\n&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="在任务完成时执行完成block">在任务完成时执行完成Block</h3><p>就其性质而言, 调度到队列中的任务是独立于创建它们的代码运行的。然而，当任务完成后，程序可能仍然希望被通知这一事实，以便它能够纳入结果。在传统的异步编程中，你可能会使用回调机制来做到这一点，但对于调度队列，你可以使用完成block实现。</p><p>完成block只是另一段普通代码而已，在原始任务结束后将其调度到队列中。调用代码通常在启动任务时提供完成block作为参数。任务代码所要做的就是在完成工作时将指定的block或函数提交到指定的队列中。</p><p>清单3-4显示了一个用block实现的求平均值函数。求平均值函数的最后两个参数允许调用者在报告结果时指定一个队列和block。在求平均值函数计算出它的值后，它将结果传递给指定的block，并将其调度给队列。为了防止队列过早地被释放，在开始的时候保留该队列并在完成block被调度时进行释放。</p><p><strong>清单3-4</strong> 在一个任务完成后执行回调</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> average_async(<span class="keyword">int</span> *data, size_t len,</span><br><span class="line">   <span class="built_in">dispatch_queue_t</span> queue, <span class="keyword">void</span> (^block)(<span class="keyword">int</span>))</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Retain the queue provided by the user to make</span></span><br><span class="line">   <span class="comment">// sure it does not disappear before the completion</span></span><br><span class="line">   <span class="comment">// block can be called.</span></span><br><span class="line">   dispatch_retain(queue);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Do the work on the default concurrent queue and then</span></span><br><span class="line">   <span class="comment">// call the user-provided block with the results.</span></span><br><span class="line">   <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">      <span class="keyword">int</span> avg = average(data, len);</span><br><span class="line">      <span class="built_in">dispatch_async</span>(queue, ^&#123; block(avg);&#125;);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Release the user-provided queue when done</span></span><br><span class="line">      dispatch_release(queue);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发执行循环迭代">并发执行循环迭代</h3><p>并发调度队列可以提高性能的一个地方是，一个执行固定次数迭代的循环。例如，假设你有一个for循环，在每次循环迭代中都做一些工作：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">   printf(<span class="string">&quot;%u\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在每个迭代过程中执行的工作与所有其他迭代过程中执行的工作不同，并且每个连续的循环完成的顺序不重要，你可以用调用<code>dispatch_apply</code>或<code>dispatch_apply_f</code>函数来代替循环。这些函数在每次循环迭代时将指定的block或函数提交给一个队列。当调度到一个并发队列时，因此有可能同时执行多个循环迭代。</p><p>在调用<code>dispatch_apply</code>或<code>dispatch_apply_f</code>时，你可以指定一个串行队列或并发队列。传递一个并发队列允许你同时执行多个循环迭代，这是使用这些函数的最常见方式。尽管使用一个串行队列是允许的，并且对你的代码来说是正确的，但使用这样的队列与原有的循环相比没有真正的性能优势。</p><p><strong>重要提醒：</strong>和普通的for循环一样，<code>dispatch_apply</code>和<code>dispatch_apply_f</code>函数在所有循环迭代完成之前不会返回。因此，当已经从队列的上下文中执行的代码中调用它们时，应该小心。如果作为参数传递给函数的队列是一个串行队列，并且是执行当前代码的同一个队列，调用这些函数将使队列陷入死锁。</p><p>因为它们实际上阻塞了当前线程，所以当你从主线程中调用这些函数时也要小心，它们可能会阻止你的事件处理循环及时地响应事件。如果循环代码需要明显的处理时间，你可能想从不同的线程调用这些函数。</p><p>清单3-5显示了如何用<code>dispatch_apply</code>语法替换前面的for循环。传递给<code>dispatch_apply</code>函数的block必须包含一个识别当前循环迭代的参数。当block被执行时，这个参数的值对于第一次迭代是<code>0</code>，对于第二次迭代是<code>1</code>，以此类推。最后一次迭代的参数值是<code>count - 1</code>，其中<code>count</code>是迭代的总次数。</p><p><strong>清单3-5</strong> 并发执行for循环迭代</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">dispatch_apply(count, queue, ^(size_t i) &#123;</span><br><span class="line">   printf(<span class="string">&quot;%u\n&quot;</span>,i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>你应该确保任务代码在每次迭代中都能完成合理的工作量。就像你调度到队列的任何block或函数一样，调度该代码的执行是有开销的。如果你的循环的每个迭代只执行少量的工作，调度代码的开销可能会超过你从调度它到队列中可能获得的性能优势。如果你在测试过程中发现这种情况，你可以使用striding来增加每个循环迭代中执行的工作量。通过striding，将原始循环的多次迭代合并成一个block，并按比例减少迭代次数。例如，如果你最初执行了100次迭代，但决定使用4的跨度，你现在从每个block中执行4次循环迭代，迭代次数是25。关于如何实现striding的例子，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW2">Improving on Loop Code</a>。</p><h3 id="在主线程上执行任务">在主线程上执行任务</h3><p>Grand Central Dispatch提供了一个特殊的调度队列，你可以用它来在程序的主线程上执行任务。这个队列是为所有程序自动提供的，任何在其主线程上设置run loop（由<code>CFRunLoopRef</code>类型或<code>NSRunLoop</code>对象管理）的程序都会自动drained。如果你没有创建一个Cocoa应用程序，并且不想明确设置一个run loop，你必须调用<code>dispatch_main</code>函数来明确消费主调度队列。你仍然可以向队列添加任务，但如果你不调用这个函数，这些任务就永远不会被执行。</p><p>你可以通过调用<code>dispatch_get_main_queue</code>函数获得程序主线程的调度队列。添加到这个队列的任务是在主线程本身上串行进行的。因此，你可以把这个队列作为一个用于同步其他部分进行的工作的同步点。</p><h3 id="在任务中使用objective-c对象">在任务中使用Objective-C对象</h3><p>GCD提供了对Cocoa内存管理技术的内置支持，因此你可以在提交给调度队列的block中自由使用Objective-C对象。每个调度队列都维护它自己的自动释放池，以确保自动释放的对象在某一时刻被释放；队列不保证它们何时真正释放这些对象。</p><p>如果程序有内存限制，并且block创建了超过几个自动释放的对象，创建自己的自动释放池是确保对象被及时释放的唯一方法。如果你的block创建了数以百计的对象，你可能需要创建多个自动释放池，或者定期清空池。</p><h2 id="暂停和恢复队列">暂停和恢复队列</h2><p>可以通过暂停一个队列来阻止暂时执行block对象。你可以使用<code>dispatch_suspend</code>函数暂停一个调度队列，并使用<code>dispatch_resume</code>函数恢复它。调用<code>dispatch_suspend</code>会增加队列的暂停引用计数，而调用<code>dispatch_resume</code>会减少引用计数。当引用计数大于0时，队列仍然暂停。因此，你必须用一个匹配的恢复调用来平衡所有的暂停调用，以便恢复处理block。</p><p><strong>重要提醒：</strong>暂停和恢复调用是异步的，只在block的执行之间生效。暂停队列不会停止已经执行的block。</p><h2 id="使用调度信号量来规范有限资源的使用">使用调度信号量来规范有限资源的使用</h2><p>如果你提交给调度队列的任务要访问一些有限的资源，你可以使用调度信号量来调节同时访问该资源的任务数量。调度信号量的工作方式与普通信号量一样，但有一个例外。当资源可用时，获取一个调度信号量的时间比获取一个传统系统信号量的时间要短。这是因为Grand Central Dispatch在这种特殊情况不会向下调用内核。唯一一次调用内核是当资源不可用时，系统需要暂停（park）线程直到发出信号。</p><p>使用调度信号量的语义如下：</p><ol type="1"><li>创建信号量时（使用<code>dispatch_semaphore_create</code>函数），可以指定一个正整数，表示可用资源的数量。</li><li>在每个任务中，调用<code>dispatch_semaphore_wait</code>等待信号量。</li><li>当等待调用返回时，获取资源并完成工作。</li><li>使用完资源后，释放它并通过调用<code>dispatch_semaphore_signal</code>函数发出信号量。</li></ol><p>关于这些步骤如何工作的例子，可以考虑系统中文件描述符的使用。每个程序都有有限的文件描述符可以使用。如果有一个处理大量文件的任务，你不希望一次打开这么多文件，以至于你的文件描述符用完。相反，你可以使用信号量来限制文件处理代码使用的文件描述符的数量。你可以在任务中加入以下的基本代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the semaphore, specifying the initial pool size</span></span><br><span class="line">dispatch_semaphore_t fd_sema = dispatch_semaphore_create(getdtablesize() / <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Wait for a free file descriptor</span></span><br><span class="line">dispatch_semaphore_wait(fd_sema, DISPATCH_TIME_FOREVER);</span><br><span class="line">fd = open(<span class="string">&quot;/etc/services&quot;</span>, O_RDONLY);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Release the file descriptor when done</span></span><br><span class="line">close(fd);</span><br><span class="line">dispatch_semaphore_signal(fd_sema);</span><br></pre></td></tr></table></figure><p>创建信号量时，指定可用资源的数量。该值成为信号量的初始计数变量。每次等待信号量时，<code>dispatch_semaphore_wait</code>函数都会将计数变量递减 1。如果结果值为负，该函数会告诉内核阻塞线程。另一方面，<code>dispatch_semaphore_signal</code>函数将 count 变量加 1 以指示资源已被释放。如果有任务被阻塞并等待资源，其中一个任务随后会被解除阻塞并被允许进行工作。</p><h2 id="等待排队的任务组">等待排队的任务组</h2><p>调度组是一种阻塞线程，直到一个或多个任务执行完毕的方式。你可以在需要等待所有指定的任务都完成才能进行某些任务的地方使用这种行为。例如，在调度了几个任务来计算一些数据后，你可以使用一个组来等待这些任务，然后在它们完成后处理结果。使用调度组的另一种方式是作为线程连接的替代。你可以将相应的任务添加到一个调度组中，并等待整个组，而不是启动几个子线程，然后与每个子线程联合起来。</p><p>清单3-6显示了建立一个组，向其调度任务并等待结果的基本过程。没有使用<code>dispatch_async</code>函数将任务调度到队列，而是使用<code>dispatch_group_async</code>函数。这个函数将任务与组相关联，并排队等待执行。要等待一组任务的完成，你就使用<code>dispatch_group_wait</code>函数，传入适当的组。</p><p><strong>清单3-6</strong> 等待异步任务</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Add a task to the group</span></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">   <span class="comment">// Some asynchronous work</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Do some other work while the tasks execute.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// When you cannot make any more forward progress,</span></span><br><span class="line"><span class="comment">// wait on the group to block the current thread.</span></span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Release the group when it is no longer needed.</span></span><br><span class="line">dispatch_release(group);</span><br></pre></td></tr></table></figure><h2 id="调度队列和线程安全">调度队列和线程安全</h2><p>在调度队列的背景下谈论线程安全可能看起来很奇怪，但线程安全仍然是一个相关的话题。任何时候，当你在程序中实现并发时，有几件事你应该知道：</p><ul><li>调度队列本身是线程安全的。换句话说，你可以从系统中的任何线程向调度队列提交任务，而不必首先取得锁或同步访问队列。</li><li>不要从一个正在执行的任务中调用<code>dispatch_sync</code>函数，并传递当前函数调用的队列。这样做会使队列陷入死锁。如果你需要对当前队列进行调度，请使用<code>dispatch_async</code>函数进行异步调度。</li><li>避免从你提交给调度队列的任务中获取锁。尽管从任务中使用锁是安全的，但当你获得锁时，如果该锁不可用，你有可能完全阻塞一个串行队列。同样，对于并发队列来说，等待一个锁可能反而会阻止其他任务的执行。如果你需要同步你的部分代码，则使用一个串行调度队列而不是锁。</li><li>尽管你可以获得关于运行任务的底层线程的信息，但最好还是不要这样做。关于调度队列与线程的兼容性的更多信息，可参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW18">Compatibility with POSIX Threads</a>。</li></ul><p>关于如何将现有的线程代码改为使用调度队列的其他技巧，可参阅<a href=".%2F05%20Migrating%20Away%20from%20Threads.md">迁移线程代码</a>。</p><h2 id="总结">总结</h2><p>队列：</p><ul><li>在使用上，与操作队列较大的不同的是，调度队列是基于block添加任务的，而操作队列是基于操作对象添加任务的，所以调度队列会少了一些对每个任务的控制，例如任务添加到调度队列时，必须是就绪执行的。</li><li>对于操作对象之间的依赖，在调度队列中的替代方案是串行队列和调度组。</li><li>对于操作队列的完成block，在调度队列中可以简单在添加的工作单元block中插入执行完成回调block的代码。</li><li>如果block创建了几个以上的Objective-C对象，你可以把block的部分代码包裹在@autorelease中，以处理这些对象的内存管理。尽管GCD调度队列有他们自己的自动释放池，但他们不保证这些池何时被耗尽。如果程序有内存限制，创建自己的自动释放池可以让你在更有规律的时间间隔内释放自动释放对象的内存。</li><li>全局队列除了主队列，其他4个都是并发队列，并按照优先级区分。</li><li>只要以异步方式向队列提交任务，该队列就不会出现死锁。同步进入正在执行的队列，必然造成死锁。</li><li>如果你想同时执行大量的任务，请将它们提交给全局并发队列。</li><li>当给调度队列设置了自己的上下文数据是（<code>dispatch_set_context</code>），要相应地设置清理函数（<code>dispatch_set_finalizer_f</code>）以释放自己的上下文数据。</li><li>在使用调度函数<code>dispatch_apply</code>或<code>dispatch_apply_f</code>优化循环时，传入并发队列才是有意义的，不然根直接执行没有区别。</li><li>避免从提交给调度队列的任务重获取锁。这不仅会阻塞串行队列，也会让并发队列阻止其他任务的执行。即会让队列不可预测，要同步代码，应使用串行队列而不是锁。</li></ul><p>使用技巧：</p><ul><li>基于队列的同步比锁更有效，因为锁在有争议和无争议的情况下总是需要一个昂贵的内核陷阱（kernel trap），而调度队列主要在程序的进程空间工作，只有在绝对必要时才会向下调用内核。</li><li>对于并发队列，若不是需要操作队列，如挂起，否则使用全局并发队列即可。</li><li>在创建串行队列时，尽量为每个队列确定一个目的，如保护资源或同步程序的一些关键行为。</li><li>除非遇到竞态条件或其他同步错误，否则都尽可能地异步添加任务。异步添加任务到串行队列实现了异步锁。</li></ul><h3 id="objective-c-api---swift-api">Objective-C API -&gt; Swift API</h3><p><code>dispatch_barrier_async</code> -&gt; <code>async</code>设置flags值为<code>.barrier</code></p><p><code>dispatch_after</code> -&gt; <code>asyncAfter</code></p><p><code>dispatch_once</code> -&gt; 无</p><p><code>dispatch_apply</code> -&gt; <code>concurrentPerform</code></p><h3 id="一次执行">一次执行</h3><p>Swift中没有提供，可自己实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">DispatchQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> _onceTracker <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">once</span>(<span class="title">file</span>: <span class="title">String</span> = #<span class="title">file</span>, <span class="title">function</span>: <span class="title">String</span> = #<span class="title">function</span>, <span class="title">line</span>: <span class="title">Int</span> = #<span class="title">line</span>, <span class="title">block</span>: () -&gt; <span class="title">Void</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> token <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(file)</span>:<span class="subst">\(function)</span>:<span class="subst">\(line)</span>&quot;</span></span><br><span class="line">        once(token: token, block: block)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">once</span>(<span class="title">token</span>: <span class="title">String</span>, <span class="title">block</span>: () -&gt; <span class="title">Void</span>) </span>&#123;</span><br><span class="line">        objc_sync_enter(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            objc_sync_exit(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>_onceTracker.contains(token) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        _onceTracker.append(token)</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objc_sync_enter</code>和<code>objc_sync_exit</code>共同实现<code>@sychronized</code>递归锁。</p><h3 id="屏障barrier">屏障（barrier）</h3><p>注意：在全局并发队列中插入屏障无效，跟普通的<code>async</code>效果一致，起不到阻塞的作用。</p><p>插入屏障任务对并发队列的作用：</p><ol type="1"><li>等待在屏障任务之前的任务完成；</li><li>执行屏障任务，并等待完成；</li><li>继续执行后续其他任务。</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    <span class="type">DispatchQueueExp</span>.testTask(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    <span class="type">DispatchQueueExp</span>.testTask(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.async(flags: .barrier) &#123;</span><br><span class="line">    <span class="type">DispatchQueueExp</span>.testTask(<span class="string">&quot;Barrier-C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    <span class="type">DispatchQueueExp</span>.testTask(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    <span class="type">DispatchQueueExp</span>.testTask(<span class="string">&quot;F&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A开始-testTask(_:):&lt;NSThread: 0x6000025adec0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">B开始-testTask(_:):&lt;NSThread: 0x6000025e8340&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">B结束-testTask(_:):&lt;NSThread: 0x6000025e8340&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">A结束-testTask(_:):&lt;NSThread: 0x6000025adec0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">Barrier-C开始-testTask(_:):&lt;NSThread: 0x6000025adec0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">Barrier-C结束-testTask(_:):&lt;NSThread: 0x6000025adec0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">D开始-testTask(_:):&lt;NSThread: 0x6000025adec0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">F开始-testTask(_:):&lt;NSThread: 0x6000025962c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">D结束-testTask(_:):&lt;NSThread: 0x6000025adec0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">F结束-testTask(_:):&lt;NSThread: 0x6000025962c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="调度信号量">调度信号量</h3><ul><li>调度信号量用于在访问一些有限资源时，用它来控制同时访问资源的任务数量。</li><li>调度信号量比传统信号量有更好的性能。传统信号量总是需要调用内核来测试信号量。因为当资源可用的时候，获取一个信号量比获取传统信号量更快，因为当资源可用时调度信号量不会向下调用内核。唯一调用内核的实际时机时资源不可用时，系统暂停线程直到发出信号。</li><li>如果是为了对资源加锁，那么使用串行队列可能性能更优。</li><li>信号量值 ≤ 0，则阻塞当前线程进入休眠等待，直到信号量值 &gt; 0。</li><li>使用调度信号量的步骤：<ol type="1"><li>创建信号量，传入可用资源数量。</li><li><code>wait</code>让信号量-1，表示已占用一个资源。</li><li>执行任务。完成时，调用<code>signal</code>让信号量+1，表释放资源。</li></ol></li><li>注意，若在销毁时信号量的值小于初始值，则会崩溃（BUG IN CLIENT OF LIBDISPATCH: Semaphore object deallocated while in use）。</li><li>当初始值为0的信号量，可以用作锁，即调用<code>wait</code>马上阻塞线程，<code>signal</code>才解开线程。例如可以让异步操作变成同步操作。</li></ul><p>应用：</p><ul><li>异步变同步</li><li>控制并发量，Metal绘制经常使用。</li></ul><p>控制并发量</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span>(<span class="params">label</span>: <span class="type">String</span>, <span class="params">cost</span>: <span class="type">UInt32</span>, <span class="params">complete</span>:<span class="keyword">@escaping</span> ()-&gt;())</span>&#123;</span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">&quot;Start task%@&quot;</span>,label)</span><br><span class="line">    sleep(cost)</span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">&quot;End task%@&quot;</span>,label)</span><br><span class="line">    complete()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>(value: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;&quot;</span>, qos: .default, attributes: .concurrent)</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    semaphore.wait()</span><br><span class="line">    <span class="keyword">self</span>.doSomething(label: <span class="string">&quot;1&quot;</span>, cost: <span class="number">2</span>, complete: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">Thread</span>.current)</span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    semaphore.wait()</span><br><span class="line">    <span class="keyword">self</span>.doSomething(label: <span class="string">&quot;2&quot;</span>, cost: <span class="number">2</span>, complete: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">Thread</span>.current)</span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    semaphore.wait()</span><br><span class="line">    <span class="keyword">self</span>.doSomething(label: <span class="string">&quot;3&quot;</span>, cost: <span class="number">4</span>, complete: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">Thread</span>.current)</span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    semaphore.wait()</span><br><span class="line">    <span class="keyword">self</span>.doSomething(label: <span class="string">&quot;4&quot;</span>, cost: <span class="number">2</span>, complete: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">Thread</span>.current)</span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    semaphore.wait()</span><br><span class="line">    <span class="keyword">self</span>.doSomething(label: <span class="string">&quot;5&quot;</span>, cost: <span class="number">3</span>, complete: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">Thread</span>.current)</span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调度组">调度组</h3><ul><li>调度组是一种在一或多个任务执行完毕之前阻塞线程的方式。</li></ul><p>DispatchGroup两种用法:</p><p>一、调度队列调度时传入调度组</p><p>最简单的用法。</p><p>notify：对组做完成监听。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line">myQueue<span class="operator">?</span>.async(group: group, qos: .default, flags: [], execute: &#123; </span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;耗时任务一&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">myQueue<span class="operator">?</span>.async(group: group, qos: .default, flags: [], execute: &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;耗时任务二&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//执行完上面的两个耗时操作, 回到myQueue队列中执行下一步的任务</span></span><br><span class="line">group.notify(queue: myQueue<span class="operator">!</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;回到该队列中执行&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wait：阻塞线程，同步访问。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待上面任务执行，会阻塞当前线程，超时就执行下面的，上面的继续执行。可以无限等待 .distantFuture</span></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> group.wait(timeout: .now() <span class="operator">+</span> <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;不超时, 上面的两个任务都执行完&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> .timedOut:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;超时了, 上面的任务还没执行完执行这了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;接下来的操作&quot;</span>)</span><br></pre></td></tr></table></figure><p>二、enter-leave</p><p>手动管理调度组计数，<code>enter</code>和<code>leave</code>必须配对。</p><p>应用更为自由，不用给队列调用传入调度组，可在任意的队列操作调度组计数。同样最后通过notify监听完成回调。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line">group.enter()<span class="comment">//把该任务添加到组队列中执行</span></span><br><span class="line">myQueue<span class="operator">?</span>.async &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;耗时任务一&quot;</span>)</span><br><span class="line">        group.leave()<span class="comment">//执行完之后从组队列中移除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">group.enter()<span class="comment">//把该任务添加到组队列中执行</span></span><br><span class="line">myQueue<span class="operator">?</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;耗时任务二&quot;</span>)</span><br><span class="line">        group.leave()<span class="comment">//执行完之后从组队列中移除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当上面所有的任务执行完之后通知</span></span><br><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有的任务执行完了&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调度组和调度信号量都可以实现在异步调用中进行计数，除了用法不一样外，调度信号量只能用于阻塞，而调度组除了阻塞外也提供了异步监听完成的回调。</p></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Apple/" rel="tag"># Apple</a> <a href="/tags/Concurrency-Programming-Guide/" rel="tag"># Concurrency Programming Guide</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/concurrency_pg_operation_queues/" rel="prev" title="Concurrency Programming Guide：操作队列"><i class="fa fa-chevron-left"></i> Concurrency Programming Guide：操作队列</a></div><div class="post-nav-item"><a href="/posts/concurrency_pg_dispatch_sources/" rel="next" title="Concurrency Programming Guide：调度源">Concurrency Programming Guide：调度源 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let e=CONFIG.comments["activeClass"];if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="nav-text">关于调度队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF"><span class="nav-text">队列相关技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8block%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1"><span class="nav-text">使用Block来实现任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="nav-text">创建和管理调度队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97%E5%85%A8%E5%B1%80%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="nav-text">获得全局并发调度队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%B2%E8%A1%8C%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="nav-text">创建串行调度队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E8%8E%B7%E5%8F%96%E9%80%9A%E7%94%A8%E9%98%9F%E5%88%97"><span class="nav-text">在运行时获取通用队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">调度队列的内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E9%98%9F%E5%88%97%E5%AD%98%E5%82%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF"><span class="nav-text">用队列存储自定义上下文信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E9%98%9F%E5%88%97%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E6%B8%85%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">为队列提供一个清理函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1%E5%88%B0%E9%98%9F%E5%88%97"><span class="nav-text">添加任务到队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%8D%95%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%88%B0%E9%98%9F%E5%88%97"><span class="nav-text">添加单个任务到队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%BB%BB%E5%8A%A1%E5%AE%8C%E6%88%90%E6%97%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%88%90block"><span class="nav-text">在任务完成时执行完成Block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3"><span class="nav-text">并发执行循环迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8A%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="nav-text">在主线程上执行任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%BB%BB%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8objective-c%E5%AF%B9%E8%B1%A1"><span class="nav-text">在任务中使用Objective-C对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9A%82%E5%81%9C%E5%92%8C%E6%81%A2%E5%A4%8D%E9%98%9F%E5%88%97"><span class="nav-text">暂停和恢复队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%B0%83%E5%BA%A6%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9D%A5%E8%A7%84%E8%8C%83%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">使用调度信号量来规范有限资源的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E6%8E%92%E9%98%9F%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%BB%84"><span class="nav-text">等待排队的任务组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">调度队列和线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#objective-c-api---swift-api"><span class="nav-text">Objective-C API -&gt; Swift API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8C"><span class="nav-text">一次执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%8F%E9%9A%9Cbarrier"><span class="nav-text">屏障（barrier）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">调度信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%BB%84"><span class="nav-text">调度组</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="權咚" src="/images/icon.png"><p class="site-author-name" itemprop="name">權咚</p><div class="site-description" itemprop="description">🤘🤯👾</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">69</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/bqlin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bqlin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://weibo.com/hearingdog" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;hearingdog" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://xiaozhuanlan.com/metal-reference-translation" title="https:&#x2F;&#x2F;xiaozhuanlan.com&#x2F;metal-reference-translation" rel="noopener" target="_blank">Metal内参</a></li><li class="links-of-blogroll-item"><a href="https://xiaozhuanlan.com/wwdc21" title="https:&#x2F;&#x2F;xiaozhuanlan.com&#x2F;wwdc21" rel="noopener" target="_blank">WWDC21 内参</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">權咚</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">256k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">3:53</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script>document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",()=>{mermaid.initialize({theme:"default",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{scale:1,jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",vOffset:-100},mobile:{show:!1,scale:.5},log:!1})</script></body></html>